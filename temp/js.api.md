## API Report File for "@onehop/js"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type AnyId = Id<IdPrefixes>;

// @public (undocumented)
export namespace API {
        {
        channels as Channels,
        ignite as Ignite,
        pipe as Pipe,
        projects as Projects,
        registry as Registry,
        users as Users,
    };
}

// @public
export type APIAuthentication = Id<APIAuthenticationPrefix>;

// @public
export type APIAuthenticationPrefix = 'ptk' | 'bearer' | 'pat';

// @public
export class APIClient {
    constructor(options: APIClientOptions);
    // (undocumented)
    readonly authType: APIAuthenticationPrefix;
    // (undocumented)
    delete<Path extends Extract<Endpoints, {
        method: 'DELETE';
    }>['path']>(path: Path, body: Extract<Endpoints, {
        path: Path;
        method: 'DELETE';
    }>['body'], query: Query<Path>, init?: RequestInit): Promise<(Extract<Endpoint<"DELETE", "/v1/users/@me/pats/:pat_id", void>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/projects/:project_id/tokens/:project_token_id", void>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/projects/@this/tokens/:project_token_id", void>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/projects/:project_id/secrets/:secret_id", void>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/projects/@this/secrets/:secret_id", void>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/channels/:channel_id", void>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/channels/tokens/:token", void>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/ignite/deployments/:deployment_id", void>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/ignite/containers/:container_id", void | {
        container: Container;
    }>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/ignite/domains/:domain_id", void>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/pipe/rooms/:room_id", void>, {
        path: Path;
        method: 'DELETE';
    }> | Extract<Endpoint<"DELETE", "/v1/registry/images/:image", void>, {
        path: Path;
        method: 'DELETE';
    }>)["res"]>;
    // (undocumented)
    get<Path extends PathsFor<'GET'>>(path: Path, query: Query<Path>, init?: RequestInit): Promise<(Extract<Endpoint<"GET", "/v1/users/@me", {
        projects: Project[];
        user: SelfUser;
        project_member_role_map: Record<`project_${string}`, MemberRole>;
        leap_token: string | null;
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/users/@me/pats", {
        pats: PAT[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/:project_id/members/@me", {
        project_member: Member;
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/:project_id/tokens", {
        project_tokens: ProjectToken[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/@this/tokens", {
        project_tokens: ProjectToken[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/:project_id/members", {
        members: Member[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/@this/members", {
        members: Member[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/:project_id/secrets", {
        secrets: Secret[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/projects/@this/secrets", {
        secrets: Secret[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/channels/:channel_id", {
        channel: Channel;
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/channels/:channel_id/tokens", {
        tokens: ChannelToken[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/channels/:channel_id/state", {
        state: State;
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/channels", {
        channels: Channel[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/channels/tokens/:token", {
        token: ChannelToken;
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/channels/:channel_id/stats", {
        stats: {
            online_count: number;
        };
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments", {
        deployments: Deployment[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments/:deployment_id/containers", {
        containers: Container[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/containers/:container_id/logs", {
        logs: ContainerLog[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments/search", {
        deployment: Deployment;
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments/:deployment_id", {
        deployment: Deployment;
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/gateways/:gateway_id", {
        gateway: Gateway;
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments/:deployment_id/gateways", {
        gateways: Gateway[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/deployments/:deployment_id/storage", Record<"volume" | "build_cache", Record<"provisioned_size" | "used_size", number> | null>>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/ignite/domains/:domain_id", {
        domain: Domain;
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/pipe/rooms", {
        rooms: Room[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/registry/images", {
        images: string[];
    }>, {
        path: Path;
        method: 'GET';
    }> | Extract<Endpoint<"GET", "/v1/registry/images/:image/manifests", {
        manifests: {
            digest: {
                digest: string;
                size: number;
                uploaded: string;
            };
            tag: string | null;
        }[];
    }>, {
        path: Path;
        method: 'GET';
    }>)["res"]>;
    // (undocumented)
    static getAuthType(auth: APIAuthentication): APIAuthenticationPrefix;
    // (undocumented)
    patch<Path extends Extract<Endpoints, {
        method: 'PATCH';
    }>['path']>(path: Path, body: Extract<Endpoints, {
        path: Path;
        method: 'PATCH';
    }>['body'], query: Query<Path>, init?: RequestInit): Promise<(Extract<Endpoint<"PATCH", "/v1/channels/:channel_id/state", void, State>, {
        path: Path;
        method: 'PATCH';
    }> | Extract<Endpoint<"PATCH", "/v1/channels/tokens/:token", {
        token: ChannelToken;
    }, {
        expiresAt?: Timestamp | null;
        state: State;
    }>, {
        path: Path;
        method: 'PATCH';
    }> | Extract<Endpoint<"PATCH", "/v1/ignite/deployments/:deployment_id", {
        deployment: Deployment;
    }, Partial<DeploymentConfig>>, {
        path: Path;
        method: 'PATCH';
    }> | Extract<Endpoint<"PATCH", "/v1/ignite/deployments/:deployment_id/metadata", {
        deployment: Deployment;
    }, Partial<DeploymentMetaData>>, {
        path: Path;
        method: 'PATCH';
    }> | Extract<Endpoint<"PATCH", "/v1/ignite/deployments/:deployment_id/health-check", {
        health_check: HealthCheck;
    }, Partial<Omit<HealthCheck, "id">>>, {
        path: Path;
        method: 'PATCH';
    }>)["res"]>;
    // Warning: (ae-incompatible-release-tags) The symbol "post" is marked as @public, but its signature references "CreateDeploymentConfig" which is marked as @internal
    //
    // (undocumented)
    post<Path extends Extract<Endpoints, {
        method: 'POST';
    }>['path']>(path: Path, body: Extract<Endpoints, {
        path: Path;
        method: 'POST';
    }>['body'], query: Query<Path>, init?: RequestInit): Promise<(Extract<Endpoint<"POST", "/v1/users/@me/pats", {
        pat: PAT;
    }, {
        name: string;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/projects/:project_id/tokens", {
        project_token: ProjectToken & {
            project: Project;
        };
    }, {
        flags: number;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/projects/@this/tokens", {
        project_token: ProjectToken & {
            project: Project;
        };
    }, {
        flags: number;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/channels", {
        channel: Channel;
    }, {
        type: ChannelType;
        state: Record<string, any> | null;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/channels/tokens", {
        token: ChannelToken;
    }, {
        state: State;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/channels/tokens/:token/messages", void, {
        e: string;
        d: unknown;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/channels/:channel_id/messages", void, {
        e: string;
        d: unknown;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/deployments/:deployment_id/containers", {
        container: Container;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/deployments/:deployment_id/containers/:container_id", never, {
        deployment_id: `deployment_${string}`;
        container_id: `container_${string}`;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/deployments", {
        deployment: Deployment;
    }, CreateDeploymentConfig>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/gateways/:gateway_id/domains", void, {
        domain: string;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/deployments/:deployment_id/gateways", {
        gateway: Gateway;
    }, {
        type: GatewayType;
        target_port: number;
        protocol: "http" | null;
        name: string;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/deployments/:deployment_id/rollouts", {
        rollout: DeploymentRollout;
    }>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/ignite/deployments/:deployment_id/health-check", {
        health_check: HealthCheck;
    }, Omit<HealthCheck, "id">>, {
        path: Path;
        method: 'POST';
    }> | Extract<Endpoint<"POST", "/v1/pipe/rooms", {
        room: Room;
    }, {
        name: string;
        ingest_protocol: "rtmp" | "rtp";
        delivery_protocols: DeliveryProtocol[];
        region: Regions;
        ephemeral: boolean;
        llhls_config?: {
            wcl_delay: number;
            artificial_delay: number;
            max_playout_bitrate_preset: string;
        } | undefined;
    }>, {
        path: Path;
        method: 'POST';
    }>)["res"]>;
    // (undocumented)
    put<Path extends Extract<Endpoints, {
        method: 'PUT';
    }>['path']>(path: Path, body: Extract<Endpoints, {
        path: Path;
        method: 'PUT';
    }>['body'], query: Query<Path>, init?: RequestInit): Promise<(Extract<Endpoint<"PUT", "/v1/projects/:project_id/secrets/:name", {
        secret: Secret;
    }, string>, {
        path: Path;
        method: 'PUT';
    }> | Extract<Endpoint<"PUT", "/v1/projects/@this/secrets/:name", {
        secret: Secret;
    }, string>, {
        path: Path;
        method: 'PUT';
    }> | Extract<Endpoint<"PUT", "/v1/channels/:channel_id", {
        channel: Channel;
    }, {
        type: ChannelType;
        state: Record<string, any> | null;
    }>, {
        path: Path;
        method: 'PUT';
    }> | Extract<Endpoint<"PUT", "/v1/channels/:channel_id/subscribers/:token", void>, {
        path: Path;
        method: 'PUT';
    }> | Extract<Endpoint<"PUT", "/v1/channels/:channel_id/state", void, State>, {
        path: Path;
        method: 'PUT';
    }> | Extract<Endpoint<"PUT", "/v1/ignite/containers/:container_id/state", void, {
        preferred_state: ContainerState.RUNNING | ContainerState.STOPPED;
    }>, {
        path: Path;
        method: 'PUT';
    }>)["res"]>;
    // (undocumented)
    raw<T>(request: Request): Promise<T>;
    // (undocumented)
    readonly url: <Path extends string>(path: Path, query: Query<Path>) => string;
}

// @public
export interface APIClientOptions {
    // (undocumented)
    readonly authentication: APIAuthentication;
    // (undocumented)
    readonly baseUrl: string;
}

// @public
export type APIResponse<T> = SuccessfulAPIResponse<T> | ErroredAPIResponse;

// @public
export function assertId<T extends IdPrefixes = IdPrefixes>(maybeId: string | undefined | null, prefix?: T | T[], message?: string): asserts maybeId is Id<T>;

// @public
export interface Auth {
    // (undocumented)
    password: string;
    // (undocumented)
    username: string;
}

// @public
export const BROAD_PERMISSIONS_MAP: {
    MANAGE_MEMBERS: bigint;
    MANAGE_PROJECT_TOKENS: bigint;
    MANAGE_DEPLOYMENTS: bigint;
    MANAGE_PIPE: bigint;
    MANAGE_SECRETS: bigint;
    MANAGE_CHANNELS: bigint;
    MANAGE_REGISTRY: bigint;
    READ_ONLY: bigint;
    MANAGE_QUOTAS: bigint;
    MANAGE_ROLLOUTS: bigint;
    MANAGE_BILLING: bigint;
};

// @public
export interface Build {
    created_at?: Timestamp;
    deployment_id: Id<'deployment'>;
    digest: string | null;
    environment: BuildEnvironment | null;
    finished_at: Timestamp | null;
    id: Id<'build'>;
    metadata: BuildMetaData | null;
    method: BuildMethod;
    started_at: Timestamp | null;
    state: BuildState;
    validation_failure: ValidationFailure | null;
}

// @public
export interface BuildEnvironment {
    // (undocumented)
    nix_plan?: NixPlan | null;
    // (undocumented)
    type: BuildEnvironmentType;
}

// @public
export enum BuildEnvironmentType {
    // (undocumented)
    DOCKERFILE = "dockerfile",
    // (undocumented)
    NIXPACKS = "nixpacks"
}

// @public
export interface BuildMetaData {
    account_type?: 'user' | 'organization';
    author?: {
        avatar_url: string;
        username: string;
    };
    branch: string;
    commit_msg: string;
    commit_sha: string;
    commit_url?: string;
    repo_id: number;
    repo_name: string;
}

// @public
export enum BuildMethod {
    // (undocumented)
    CLI = "cli",
    // (undocumented)
    GITHUB = "github"
}

// @public (undocumented)
export interface BuildSettings {
    root_directory?: string;
}

// @public
export enum BuildState {
    // (undocumented)
    CANCELLED = "cancelled",
    // (undocumented)
    FAILED = "failed",
    // (undocumented)
    PENDING = "pending",
    // (undocumented)
    SUCCEEDED = "succeeded",
    // (undocumented)
    VALIDATING = "validating",
    // (undocumented)
    VALIDATION_FAILED = "validation_failed"
}

// @public
export function bytes(size: number, unit?: ByteUnit): ByteSizeString;

// @public
export type ByteSizeString = `${number}${ByteUnit}`;

// @public @deprecated
export type ByteString = ByteSizeString;

// @public
export type ByteUnit = typeof byteUnits[number];

// @public
export const byteUnits: readonly ["GB", "MB", "KB", "B"];

// @public
export interface Channel {
    capabilities: number;
    created_at: Timestamp;
    id: string;
    project: Project;
    state: State;
    type: ChannelType;
}

// @public
export type ChannelEndpoints = Endpoint<'POST', '/v1/channels', {
    channel: Channel;
}, {
    type: ChannelType;
    state: Record<string, any> | null;
}> | Endpoint<'PUT', '/v1/channels/:channel_id', {
    channel: Channel;
}, {
    type: ChannelType;
    state: Record<string, any> | null;
}> | Endpoint<'POST', '/v1/channels/tokens', {
    token: ChannelToken;
}, {
    state: State;
}> | Endpoint<'DELETE', '/v1/channels/:channel_id', Empty> | Endpoint<'GET', '/v1/channels/:channel_id', {
    channel: Channel;
}> | Endpoint<'GET', '/v1/channels/:channel_id/tokens', {
    tokens: ChannelToken[];
}> | Endpoint<'POST', '/v1/channels/tokens/:token/messages', Empty, {
    e: string;
    d: unknown;
}> | Endpoint<'PUT', '/v1/channels/:channel_id/subscribers/:token', Empty> | Endpoint<'PATCH', '/v1/channels/:channel_id/state', Empty, State> | Endpoint<'PUT', '/v1/channels/:channel_id/state', Empty, State> | Endpoint<'GET', '/v1/channels/:channel_id/state', {
    state: State;
}> | Endpoint<'POST', '/v1/channels/:channel_id/messages', Empty, {
    e: string;
    d: unknown;
}> | Endpoint<'GET', '/v1/channels', {
    channels: Channel[];
}> | Endpoint<'GET', '/v1/channels/tokens/:token', {
    token: ChannelToken;
}> | Endpoint<'PATCH', '/v1/channels/tokens/:token', {
    token: ChannelToken;
}, {
    expiresAt?: Timestamp | null;
    state: ChannelToken['state'];
}> | Endpoint<'DELETE', '/v1/channels/tokens/:token', Empty> | Endpoint<'GET', '/v1/channels/:channel_id/stats', {
    stats: {
        online_count: number;
    };
}>;

// @public (undocumented)
export namespace Channels {
        {
        channels_Channel as Channel,
        channels_ChannelEndpoints as ChannelEndpoints,
        channels_ChannelToken as ChannelToken,
        channels_ChannelType as ChannelType,
        channels_State as State,
    };
}

// @public (undocumented)
export interface ChannelToken {
    id: Id<'leap_token'>;
    is_online: boolean;
    project_id: Id<'project'>;
    state: State;
}

// @public
export enum ChannelType {
    // (undocumented)
    PRIVATE = "private",
    // (undocumented)
    PUBLIC = "public",
    // (undocumented)
    UNPROTECTED = "unprotected"
}

// @public (undocumented)
export interface Container {
    created_at: Timestamp;
    deployment_id: Id<'deployment'>;
    id: Id<'container'>;
    internal_ip: string;
    metadata: {
        last_exit_code?: number;
    };
    metrics: {
        cpu_usage_percent: number;
        memory_usage_percent: number;
    } | null;
    overrides: {
        resources?: Partial<Resources>;
    } | null;
    region: Regions;
    state: ContainerState;
    type: RuntimeType;
    uptime: {
        last_start: Timestamp;
    };
    volume: VolumeDefinition | null;
}

// @public
export interface ContainerLog {
    level: 'info' | 'error';
    message: string;
    nonce: string;
    timestamp: Timestamp;
}

// @public
export enum ContainerState {
    EXITED = "exited",
    FAILED = "failed",
    PENDING = "pending",
    RUNNING = "running",
    STOPPED = "stopped",
    TERMINATING = "terminating"
}

// @public
export enum ContainerStrategy {
    MANUAL = "manual"
}

// Warning: (ae-internal-missing-underscore) The name "CreateDeploymentConfig" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type CreateDeploymentConfig = MakeOptional<DeploymentConfig, 'cmd'>;

// @public
export const DEFAULT_BASE_URL = "https://api.hop.io";

// @public (undocumented)
export interface DefaultQuotas {
    // (undocumented)
    ram: number;
    // (undocumented)
    vcpu: number;
    // (undocumented)
    volume: number;
}

// @public (undocumented)
export type DeliveryProtocol = 'webrtc' | 'hls';

// @public (undocumented)
export interface Deployment {
    active_build: Build | null;
    // @deprecated
    active_rollout: DeploymentRollout | null;
    build_cache_enabled: boolean;
    build_id: Build['id'] | null;
    build_settings?: BuildSettings;
    config: Omit<DeploymentConfig, 'name'>;
    container_count: number;
    created_at: Timestamp;
    id: Id<'deployment'>;
    latest_rollout: DeploymentRollout | null;
    metadata: DeploymentMetaData | null;
    name: string;
    running_container_count: number;
    target_container_count: number;
}

// @public
export interface DeploymentConfig {
    cmd?: string[];
    container_strategy: ContainerStrategy;
    entrypoint?: string[];
    env: Record<string, string>;
    image: Image_2;
    name: string;
    resources: Resources;
    restart_policy: RestartPolicy;
    type: RuntimeType;
    version: '12-12-2022';
    volume?: VolumeDefinition;
}

// @public (undocumented)
export interface DeploymentMetaData {
    // (undocumented)
    container_port_mappings: Record<Id<'container'>, string[]>;
    // (undocumented)
    created_first_gateway?: boolean;
    // (undocumented)
    created_from_preset?: string;
    // (undocumented)
    ignored_boarding?: boolean;
}

// @public
export type DeploymentRollout = {
    id: Id<'rollout'>;
    deployment_id: Id<'deployment'>;
    count: number;
    created_at: Timestamp;
    state: RolloutState;
    build: Build | null;
    init_container_id: string | null;
    health_check_failed: boolean;
    last_updated_at: Timestamp;
    acknowledged: boolean;
};

// @public
export interface Domain {
    created_at: Timestamp;
    domain: string;
    id: Id<'domain'>;
    redirect: DomainRedirect | null;
    state: DomainState;
}

// @public
export interface DomainRedirect {
    // (undocumented)
    status_code: 301 | 302 | 307 | 308;
    // (undocumented)
    url: string;
}

// @public
export enum DomainState {
    // (undocumented)
    PENDING = "pending",
    // (undocumented)
    SSL_ACTIVE = "ssl_active",
    // (undocumented)
    VALID_CNAME = "valid_cname"
}

// @public
export type Empty = void;

// @public
export type Endpoint<M extends Method, Path extends string, Res, Body = undefined> = {
    method: M;
    path: Path;
    res: Res;
    body: Body;
};

// @public
export type Endpoints = IgniteEndpoints | RegistryEndpoints | UserEndpoints | ProjectsEndpoints | PipeEndpoints | ChannelEndpoints;

// @public
export type ErroredAPIResponse = {
    success: false;
    error: {
        code: string;
        message: string;
    };
};

// @public (undocumented)
export type ExtractEndpoint<Method extends string, Path extends string> = Extract<Endpoints, {
    path: Path;
    method: Method;
}>;

// @public
export type ExtractRouteParams<T extends string> = string extends T ? Record<string, string | number | undefined> : T extends `${string}:${infer Param}/${infer Rest}` ? {
    [k in Param | keyof ExtractRouteParams<Rest>]: string | number;
} : T extends `${string}:${infer Param}` ? {
    [k in Param]: string | number;
} : {};

// @public
export interface Gateway {
    created_at: Timestamp;
    deployment_id: Id<'deployment'>;
    domains: Domain[];
    hopsh_domain: HopShDomain | null;
    hopsh_domain_enabled: boolean;
    id: Id<'gateway'>;
    internal_domain: InternalHopDomain | null;
    name: string;
    // @alpha
    protocol: 'http' | null;
    target_port: number | null;
    type: GatewayType;
}

// @public
export enum GatewayType {
    EXTERNAL = "external",
    INTERNAL = "internal"
}

// @public
export function getIdPrefix<T extends IdPrefixes>(id: string, expect?: T): T;

// @public
export interface GHRepo {
    // (undocumented)
    account_name: string;
    // (undocumented)
    default_branch: string;
    // (undocumented)
    full_name: string;
    // (undocumented)
    id: number;
    // (undocumented)
    private: boolean;
}

// @public
export function gigabytes(size: number): ByteSizeString;

// @public
export type HealthCheck = {
    id: Id<'health_check'>;
    protocol: 'http';
    path: string;
    port: number;
    interval: number;
    timeout: number;
    initial_delay: number;
    max_retries: number;
    created_at: Timestamp;
};

// @public
export class Hop {
    constructor(options: PartialAPIOptions);
    constructor(authentication: APIAuthentication, baseurl?: string);
    // (undocumented)
    readonly channels: {
        create<T extends State>(type: ChannelType, id?: string | null | undefined, options?: {
            state?: T;
        } | null | undefined, project?: `project_${string}` | undefined): Promise<Channel & {
            setState<T_1 extends State>(state: SetStateAction<T_1>): Promise<void>;
            patchState<T_2 extends State>(state: SetStateAction<T_2>): Promise<void>;
            subscribeToken(token: `leap_token_${string}`): Promise<void>;
            subscribeTokens(tokens: `leap_token_${string}`[] | Set<`leap_token_${string}`>): Promise<void>;
            publishMessage(name: string, data: unknown): Promise<void>;
        }>;
        get(id: string): Promise<Channel & {
            setState<T_1 extends State>(state: SetStateAction<T_1>): Promise<void>;
            patchState<T_2 extends State>(state: SetStateAction<T_2>): Promise<void>;
            subscribeToken(token: `leap_token_${string}`): Promise<void>;
            subscribeTokens(tokens: `leap_token_${string}`[] | Set<`leap_token_${string}`>): Promise<void>;
            publishMessage(name: string, data: unknown): Promise<void>;
        }>;
        getAll(project?: `project_${string}` | undefined): Promise<(Channel & {
            setState<T_1 extends State>(state: SetStateAction<T_1>): Promise<void>;
            patchState<T_2 extends State>(state: SetStateAction<T_2>): Promise<void>;
            subscribeToken(token: `leap_token_${string}`): Promise<void>;
            subscribeTokens(tokens: `leap_token_${string}`[] | Set<`leap_token_${string}`>): Promise<void>;
            publishMessage(name: string, data: unknown): Promise<void>;
        })[]>;
        subscribeToken(channel: string | Channel, token: `leap_token_${string}`): Promise<void>;
        subscribeTokens(channel: string | Channel, tokens: `leap_token_${string}`[] | Set<`leap_token_${string}`>): Promise<void>;
        getAllTokens(channel: string | Channel): Promise<ChannelToken[]>;
        setState<T_3 extends State = State>(channel: string | Channel, state: SetStateAction<T_3>): Promise<void>;
        patchState<T_4 extends State>(channel: string | Channel, state: SetStateAction<T_4>): Promise<void>;
        publishMessage<T_5>(channel: string | Channel, event: string, data: T_5): Promise<void>;
        delete(id: string): Promise<void>;
        getStats(id: string): Promise<{
            online_count: number;
        }>;
        tokens: {
            delete(token: `leap_token_${string}`): Promise<void>;
            create(state?: State, project?: `project_${string}` | undefined): Promise<ChannelToken>;
            setState(id: `leap_token_${string}`, state: State): Promise<ChannelToken>;
            get(id: `leap_token_${string}`): Promise<ChannelToken>;
            isOnline(idOrToken: `leap_token_${string}` | ChannelToken): Promise<boolean>;
            publishDirectMessage<T_6>(token: `leap_token_${string}`, event: string, data: T_6): Promise<void>;
        };
    };
    // (undocumented)
    readonly client: APIClient;
    // (undocumented)
    readonly ignite: {
        domains: {
            delete: (id: `domain_${string}`) => Promise<void>;
            get: (id: `domain_${string}`) => Promise<Domain>;
        };
        gateways: {
            addDomain(gatewayId: `gateway_${string}`, domain: string): Promise<void>;
            get(gatewayId: `gateway_${string}`): Promise<Gateway>;
            getAll(deploymentId: `deployment_${string}`): Promise<(Gateway & {
                addDomain(domain: string): Promise<void>;
                deleteDomain(domainId: `domain_${string}`): Promise<void>;
            })[]>;
            create(deployment: `deployment_${string}` | Deployment, config: {
                type: GatewayType.EXTERNAL;
                protocol: "http" | null;
                targetPort: number;
                name: string;
            } | {
                type: GatewayType.INTERNAL;
                protocol: "http" | null;
                targetPort: number;
                name: string;
                internalDomain: string;
            }): Promise<Gateway & {
                addDomain(domain: string): Promise<void>;
                deleteDomain(domainId: `domain_${string}`): Promise<void>;
            }>;
        };
        healthChecks: {
            create: (deployment: `deployment_${string}`, config: Omit<HealthCheck, "id">) => Promise<HealthCheck>;
            update: (deployment: `deployment_${string}`, config: Partial<Omit<HealthCheck, "id">>) => Promise<void>;
        };
        deployments: {
            create: {
                (configOrProject: `project_${string}`, bearerOrPatConfig: CreateDeploymentConfig): Promise<Deployment & {
                    getContainers(): Promise<Container[]>;
                    delete(): Promise<void>;
                    createContainer(): Promise<Container>;
                    createGateway(config: {
                        type: GatewayType.EXTERNAL;
                        protocol: "http" | null;
                        name: string;
                        targetPort: number;
                    } | {
                        type: GatewayType.INTERNAL;
                        protocol: "http" | null;
                        name: string;
                        targetPort: number;
                        internalDomain: string;
                    }): Promise<Gateway & {
                        addDomain(domain: string): Promise<void>;
                        deleteDomain(domainId: `domain_${string}`): Promise<void>;
                    }>;
                    getStorageStats(): Promise<Record<"volume" | "build_cache", Record<"provisioned_size" | "used_size", number> | null>>;
                }>;
                (configOrProject: CreateDeploymentConfig): Promise<Deployment & {
                    getContainers(): Promise<Container[]>;
                    delete(): Promise<void>;
                    createContainer(): Promise<Container>;
                    createGateway(config: {
                        type: GatewayType.EXTERNAL;
                        protocol: "http" | null;
                        name: string;
                        targetPort: number;
                    } | {
                        type: GatewayType.INTERNAL;
                        protocol: "http" | null;
                        name: string;
                        targetPort: number;
                        internalDomain: string;
                    }): Promise<Gateway & {
                        addDomain(domain: string): Promise<void>;
                        deleteDomain(domainId: `domain_${string}`): Promise<void>;
                    }>;
                    getStorageStats(): Promise<Record<"volume" | "build_cache", Record<"provisioned_size" | "used_size", number> | null>>;
                }>;
            };
            get: {
                (name: string, projectId?: `project_${string}` | undefined): Promise<Deployment & {
                    getContainers(): Promise<Container[]>;
                    delete(): Promise<void>;
                    createContainer(): Promise<Container>;
                    createGateway(config: {
                        type: GatewayType.EXTERNAL;
                        protocol: "http" | null;
                        name: string;
                        targetPort: number;
                    } | {
                        type: GatewayType.INTERNAL;
                        protocol: "http" | null;
                        name: string;
                        targetPort: number;
                        internalDomain: string;
                    }): Promise<Gateway & {
                        addDomain(domain: string): Promise<void>;
                        deleteDomain(domainId: `domain_${string}`): Promise<void>;
                    }>;
                    getStorageStats(): Promise<Record<"volume" | "build_cache", Record<"provisioned_size" | "used_size", number> | null>>;
                }>;
                (id: `deployment_${string}`, projectId?: `project_${string}` | undefined): Promise<Deployment & {
                    getContainers(): Promise<Container[]>;
                    delete(): Promise<void>;
                    createContainer(): Promise<Container>;
                    createGateway(config: {
                        type: GatewayType.EXTERNAL;
                        protocol: "http" | null;
                        name: string;
                        targetPort: number;
                    } | {
                        type: GatewayType.INTERNAL;
                        protocol: "http" | null;
                        name: string;
                        targetPort: number;
                        internalDomain: string;
                    }): Promise<Gateway & {
                        addDomain(domain: string): Promise<void>;
                        deleteDomain(domainId: `domain_${string}`): Promise<void>;
                    }>;
                    getStorageStats(): Promise<Record<"volume" | "build_cache", Record<"provisioned_size" | "used_size", number> | null>>;
                }>;
            };
            rollout(id: `deployment_${string}`): Promise<DeploymentRollout>;
            getStorageStats(id: `deployment_${string}`): Promise<Record<"volume" | "build_cache", Record<"provisioned_size" | "used_size", number> | null>>;
            update(deploymentId: `deployment_${string}`, config: Partial<DeploymentConfig>): Promise<Deployment>;
            getContainers(deployment: `deployment_${string}`): Promise<Container[]>;
            getAll(projectId?: `project_${string}` | undefined): Promise<(Deployment & {
                getContainers(): Promise<Container[]>;
                delete(): Promise<void>;
                createContainer(): Promise<Container>;
                createGateway(config: {
                    type: GatewayType.EXTERNAL;
                    protocol: "http" | null;
                    name: string;
                    targetPort: number;
                } | {
                    type: GatewayType.INTERNAL;
                    protocol: "http" | null;
                    name: string;
                    targetPort: number;
                    internalDomain: string;
                }): Promise<Gateway & {
                    addDomain(domain: string): Promise<void>;
                    deleteDomain(domainId: `domain_${string}`): Promise<void>;
                }>;
                getStorageStats(): Promise<Record<"volume" | "build_cache", Record<"provisioned_size" | "used_size", number> | null>>;
            })[]>;
            delete(deployment: `deployment_${string}`): Promise<void>;
            patchMetadata(deploymentId: `deployment_${string}`, metadata: Partial<DeploymentMetaData>): Promise<Deployment>;
            gateways: {
                getAll(deploymentId: `deployment_${string}`): Promise<(Gateway & {
                    addDomain(domain: string): Promise<void>;
                    deleteDomain(domainId: `domain_${string}`): Promise<void>;
                })[]>;
                create(deployment: `deployment_${string}` | Deployment, config: {
                    type: GatewayType.EXTERNAL;
                    protocol: "http" | null;
                    targetPort: number;
                    name: string;
                } | {
                    type: GatewayType.INTERNAL;
                    protocol: "http" | null;
                    targetPort: number;
                    name: string;
                    internalDomain: string;
                }): Promise<Gateway & {
                    addDomain(domain: string): Promise<void>;
                    deleteDomain(domainId: `domain_${string}`): Promise<void>;
                }>;
            };
        };
        containers: {
            delete: {
                (container_id: `container_${string}`, options: {
                    recreate: true;
                }): Promise<Container>;
                (container_id: `container_${string}`, options?: {
                    recreate?: false;
                } | undefined): Promise<undefined>;
            };
            getLogs(container: `container_${string}`, options?: Partial<{
                sortBy: "timestamp";
                orderBy: "desc" | "asc";
                limit: number;
                offset: number;
            }>): Promise<ContainerLog[]>;
            stop(container: `container_${string}`): Promise<void>;
            start(container: `container_${string}`): Promise<void>;
            create(deployment: `deployment_${string}`): Promise<Container>;
        };
    };
    // (undocumented)
    readonly pipe: {
        rooms: {
            getAll(project?: `project_${string}` | undefined): Promise<(Room & {
                delete(): Promise<void>;
            })[]>;
            create(name: string, options: {
                deliveryProtocols: DeliveryProtocol[];
                ephemeral?: boolean;
                ingestProtocol: "rtmp" | "rtp";
                hlsConfig?: {
                    wcl_delay: number;
                    artificial_delay: number;
                    max_playout_bitrate_preset: string;
                };
            }): Promise<Room & {
                delete(): Promise<void>;
            }>;
            delete(room: `pipe_room_${string}`): Promise<void>;
        };
    };
    // (undocumented)
    readonly projects: {
        getAllMembers(projectId?: `project_${string}` | undefined): Promise<Member[]>;
        getCurrentMember(projectId: `project_${string}`): Promise<Member>;
        projectTokens: {
            delete(projectTokenId: `ptkid_${string}`, project?: `project_${string}` | undefined): Promise<void>;
            get(projectId?: `project_${string}` | undefined): Promise<ProjectToken[]>;
            create(flags: number, projectId?: `project_${string}` | undefined): Promise<ProjectToken & {
                project: Project;
            }>;
        };
        tokens: {
            delete(projectTokenId: `ptkid_${string}`, project?: `project_${string}` | undefined): Promise<void>;
            get(projectId?: `project_${string}` | undefined): Promise<ProjectToken[]>;
            create(flags: number, projectId?: `project_${string}` | undefined): Promise<ProjectToken & {
                project: Project;
            }>;
        };
        secrets: {
            getAll(projectId?: `project_${string}` | undefined): Promise<Secret[]>;
            create(name: string, value: string, projectId?: `project_${string}` | undefined): Promise<Secret>;
            delete(id: string, projectId?: `project_${string}` | undefined): Promise<void>;
        };
    };
    // (undocumented)
    readonly registry: {
        images: {
            getAll(project?: `project_${string}` | undefined): Promise<string[]>;
            getManifest(image: string): Promise<{
                digest: {
                    digest: string;
                    size: number;
                    uploaded: string;
                };
                tag: string | null;
            }[]>;
            delete(image: string): Promise<void>;
        };
    };
    // (undocumented)
    readonly users: {
        me: {
            get(): Promise<{
                projects: Project[];
                user: SelfUser;
                project_member_role_map: Record<`project_${string}`, MemberRole>;
                leap_token: string | null;
            }>;
            pats: {
                create(name: string): Promise<PAT>;
                getAll(): Promise<PAT[]>;
                delete(id: `pat_${string}`): Promise<void>;
            };
        };
    };
}

// @public
export class HopAPIError extends Error {
    constructor(request: Request, response: Response, data: ErroredAPIResponse);
    // (undocumented)
    readonly data: ErroredAPIResponse;
    // (undocumented)
    readonly request: Request;
    // (undocumented)
    readonly response: Response;
    // (undocumented)
    readonly status: number;
}

// @public
export type HopShDomain = `${string}.hop.sh`;

// @public
export type Id<T extends IdPrefixes> = `${T}_${string}`;

// @public
export function id<T extends IdPrefixes = IdPrefixes>(maybeId: string | undefined | null, prefix?: T | T[]): Id<T>;

// @public
export const ID_PREFIXES: readonly [{
    readonly prefix: "user";
    readonly description: "Users";
}, {
    readonly prefix: "project";
    readonly description: "Project";
}, {
    readonly prefix: "pm";
    readonly description: "Project Members";
}, {
    readonly prefix: "role";
    readonly description: "Roles";
}, {
    readonly prefix: "pi";
    readonly description: "Project Invite";
}, {
    readonly prefix: "ptk";
    readonly description: "Project token";
}, {
    readonly prefix: "pat";
    readonly description: "User personal access token";
}, {
    readonly prefix: "container";
    readonly description: "Ignite container";
}, {
    readonly prefix: "pipe_room";
    readonly description: "Pipe room";
}, {
    readonly prefix: "deployment";
    readonly description: "Ignite deployment";
}, {
    readonly prefix: "bearer";
    readonly description: "Users bearer token";
}, {
    readonly prefix: "ptkid";
    readonly description: "Project token ID";
}, {
    readonly prefix: "secret";
    readonly description: "Project secret ID";
}, {
    readonly prefix: "gateway";
    readonly description: "Gateway";
}, {
    readonly prefix: "domain";
    readonly description: "Domain for a gateway";
}, {
    readonly prefix: "leap_token";
    readonly description: "Token for connecting to leap as a client";
}, {
    readonly prefix: "build";
    readonly description: "Build ID for build logs";
}, {
    readonly prefix: "rollout";
    readonly description: "Rollout ID for rollouts.";
}, {
    readonly prefix: "health_check";
    readonly description: "Health check ID for health checks.";
}, {
    readonly prefix: "session";
    readonly description: "Session ID for sessions on your account.";
}];

// @public
export type IdPrefixes = typeof ID_PREFIXES[number]['prefix'];

// @public (undocumented)
export namespace Ignite {
        {
        ignite_Auth as Auth,
        ignite_Build as Build,
        ignite_BuildEnvironment as BuildEnvironment,
        ignite_BuildEnvironmentType as BuildEnvironmentType,
        ignite_BuildMetaData as BuildMetaData,
        ignite_BuildMethod as BuildMethod,
        ignite_BuildSettings as BuildSettings,
        ignite_BuildState as BuildState,
        ignite_Container as Container,
        ignite_ContainerLog as ContainerLog,
        ignite_ContainerState as ContainerState,
        ignite_ContainerStrategy as ContainerStrategy,
        ignite_CreateDeploymentConfig as CreateDeploymentConfig,
        ignite_Deployment as Deployment,
        ignite_DeploymentConfig as DeploymentConfig,
        ignite_DeploymentMetaData as DeploymentMetaData,
        ignite_DeploymentRollout as DeploymentRollout,
        ignite_Domain as Domain,
        ignite_DomainRedirect as DomainRedirect,
        ignite_DomainState as DomainState,
        ignite_GHRepo as GHRepo,
        ignite_Gateway as Gateway,
        ignite_GatewayType as GatewayType,
        ignite_HealthCheck as HealthCheck,
        ignite_IgniteEndpoints as IgniteEndpoints,
        ignite_Image as Image,
        ignite_ImageGHRepo as ImageGHRepo,
        ignite_NixPlan as NixPlan,
        ignite_Regions as Regions,
        ignite_Resources as Resources,
        ignite_RestartPolicy as RestartPolicy,
        ignite_RolloutState as RolloutState,
        ignite_RuntimeType as RuntimeType,
        ignite_ValidationFailure as ValidationFailure,
        ignite_Vgpu as Vgpu,
        ignite_VgpuType as VgpuType,
        ignite_VolumeDefinition as VolumeDefinition,
        ignite_VolumeFormat as VolumeFormat,
    };
}

// Warning: (ae-incompatible-release-tags) The symbol "IgniteEndpoints" is marked as @public, but its signature references "CreateDeploymentConfig" which is marked as @internal
//
// @public
export type IgniteEndpoints = Endpoint<'GET', '/v1/ignite/deployments', {
    deployments: Deployment[];
}> | Endpoint<'GET', '/v1/ignite/deployments/:deployment_id/containers', {
    containers: Container[];
}> | Endpoint<'POST', '/v1/ignite/deployments/:deployment_id/containers', {
    container: Container;
}> | Endpoint<'POST', '/v1/ignite/deployments/:deployment_id/containers/:container_id', never, {
    deployment_id: Id<'deployment'>;
    container_id: Id<'container'>;
}> | Endpoint<'POST', '/v1/ignite/deployments', {
    deployment: Deployment;
}, CreateDeploymentConfig> | Endpoint<'DELETE', '/v1/ignite/deployments/:deployment_id', Empty> | Endpoint<'DELETE', '/v1/ignite/containers/:container_id', Empty | {
    container: Container;
}> | Endpoint<'GET', '/v1/ignite/containers/:container_id/logs', {
    logs: ContainerLog[];
}> | Endpoint<'GET', '/v1/ignite/deployments/search', {
    deployment: Deployment;
}> | Endpoint<'GET', '/v1/ignite/deployments/:deployment_id', {
    deployment: Deployment;
}> | Endpoint<'PUT', '/v1/ignite/containers/:container_id/state', Empty, {
    preferred_state: ContainerState.STOPPED | ContainerState.RUNNING;
}> | Endpoint<'POST', '/v1/ignite/gateways/:gateway_id/domains', Empty, {
    domain: string;
}> | Endpoint<'GET', '/v1/ignite/gateways/:gateway_id', {
    gateway: Gateway;
}> | Endpoint<'GET', '/v1/ignite/deployments/:deployment_id/gateways', {
    gateways: Gateway[];
}> | Endpoint<'POST', '/v1/ignite/deployments/:deployment_id/gateways', {
    gateway: Gateway;
}, {
    type: GatewayType;
    target_port: number;
    protocol: Gateway['protocol'];
    name: string;
}> | Endpoint<'PATCH', '/v1/ignite/deployments/:deployment_id', {
    deployment: Deployment;
}, Partial<DeploymentConfig>> | Endpoint<'PATCH', '/v1/ignite/deployments/:deployment_id/metadata', {
    deployment: Deployment;
}, Partial<DeploymentMetaData>> | Endpoint<'POST', '/v1/ignite/deployments/:deployment_id/rollouts', {
    rollout: DeploymentRollout;
}> | Endpoint<'POST', '/v1/ignite/deployments/:deployment_id/health-check', {
    health_check: HealthCheck;
}, Omit<HealthCheck, 'id'>> | Endpoint<'GET', '/v1/ignite/deployments/:deployment_id/storage', Record<'volume' | 'build_cache', Record<'provisioned_size' | 'used_size', number> | null>> | Endpoint<'PATCH', '/v1/ignite/deployments/:deployment_id/health-check', {
    health_check: HealthCheck;
}, Partial<Omit<HealthCheck, 'id'>>> | Endpoint<'DELETE', '/v1/ignite/domains/:domain_id', Empty> | Endpoint<'GET', '/v1/ignite/domains/:domain_id', {
    domain: Domain;
}>;

// @public
interface Image_2 {
    auth: Auth | null;
    gh_repo: ImageGHRepo | null;
    name: string | null;
}
export { Image_2 as Image }

// @public
export interface ImageGHRepo {
    // (undocumented)
    branch: string;
    // (undocumented)
    full_name: string;
    // (undocumented)
    repo_id: number;
}

// @public
export type InternalHopDomain = `${string}.hop`;

// @public
export const IS_BROWSER: boolean;

// @public
export function isValidByteString(value: string): value is ByteSizeString;

// @public
export function kilobytes(size: number): ByteSizeString;

// @public
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// @public
export function megabytes(size: number): ByteSizeString;

// @public (undocumented)
export type Member = Omit<User, 'email' | 'id'> & {
    id: Id<'pm'>;
    role: MemberRole;
    mfa_enabled: boolean;
    joined_at: Timestamp;
};

// @public (undocumented)
export interface MemberRole {
    flags: number;
    id: Id<'role'>;
    name: string;
}

// @public
export type Method = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';

// @public
export interface NixPlan {
    // (undocumented)
    cmds: {
        build: string | null;
        start: string | null;
        install: string | null;
    };
    // (undocumented)
    language: string | null;
    // (undocumented)
    pkgs: string[] | null;
}

// @public
export function parseSize(size: string): number;

// @public
export type PartialAPIOptions = Partial<Omit<APIClientOptions, 'authentication'>> & Pick<APIClientOptions, 'authentication'>;

// @public
export interface PAT {
    created_at: Timestamp;
    id: Id<'pat'>;
    name: string | null;
    // @alpha
    pat: string;
}

// @public (undocumented)
export type PathsFor<M extends Method> = Extract<Endpoints, {
    method: M;
}>['path'];

// @public
export const permissions: {
    add(value: bigint, flag: bigint): bigint;
    test(value: bigint, flag: bigint): boolean;
    subtract(value: bigint, flag: bigint): bigint;
};

// @public
export const permissionsMap: {
    add_member: bigint;
    remove_member: bigint;
    get_project_members: bigint;
    delete_project: bigint;
    delete_deployment: bigint;
    delete_container: bigint;
    update_container_state: bigint;
    read_deployments: bigint;
    create_deployment: bigint;
    create_container: bigint;
    update_container_config: bigint;
    create_room: bigint;
    read_room: bigint;
    delete_room: bigint;
    create_room_producer: bigint;
    create_project_token: bigint;
    delete_project_token: bigint;
    read_project_tokens: bigint;
    read_container_logs: bigint;
    create_project_secret: bigint;
    read_project_secrets: bigint;
    delete_project_secret: bigint;
    get_registry_images: bigint;
    create_channel_token: bigint;
    create_gateway: bigint;
    add_domain: bigint;
    delete_channels: bigint;
    update_channel_state: bigint;
    read_channels: bigint;
    publish_channel_messages: bigint;
    manage_channel_subscribers: bigint;
    delete_domain: bigint;
    delete_gateway: bigint;
    get_internal_domain: bigint;
    create_leap_token: bigint;
    read_leap_tokens: bigint;
    update_leap_token: bigint;
    message_token: bigint;
    create_channel: bigint;
    rollout: bigint;
    request_quota_increase: bigint;
    read_billing: bigint;
    read_gateways: bigint;
    delete_registry_images: bigint;
    container_ssh: bigint;
    tunnel_deployment: bigint;
};

// @public (undocumented)
export namespace Pipe {
        {
        pipe_DeliveryProtocol as DeliveryProtocol,
        pipe_PipeEndpoints as PipeEndpoints,
        pipe_Room as Room,
    };
}

// @public (undocumented)
export type PipeEndpoints = Endpoint<'GET', '/v1/pipe/rooms', {
    rooms: Room[];
}> | Endpoint<'POST', '/v1/pipe/rooms', {
    room: Room;
}, {
    name: string;
    ingest_protocol: 'rtmp' | 'rtp';
    delivery_protocols: DeliveryProtocol[];
    region: Regions;
    ephemeral: boolean;
    llhls_config?: {
        wcl_delay: number;
        artificial_delay: number;
        max_playout_bitrate_preset: string;
    } | undefined;
}> | Endpoint<'DELETE', '/v1/pipe/rooms/:room_id', Empty>;

// @public (undocumented)
export interface Project {
    created_at: Timestamp;
    // (undocumented)
    default_quotas: DefaultQuotas;
    icon: string | null;
    id: Id<'project'>;
    name: string;
    namespace: string;
    // (undocumented)
    quota_overrides: QuotaOverrides;
    // (undocumented)
    quota_usage: QuotaUsage;
    tier: ProjectTier;
    type: ProjectType;
}

// @public
export enum PROJECT_PERMISSION {
    // (undocumented)
    ADD_DOMAIN = "add_domain",
    // (undocumented)
    ADD_MEMBER = "add_member",
    // (undocumented)
    CONTAINER_SSH = "container_ssh",
    // (undocumented)
    CREATE_CHANNEL = "create_channel",
    // (undocumented)
    CREATE_CHANNEL_TOKEN = "create_channel_token",
    // (undocumented)
    CREATE_CONTAINER = "create_container",
    // (undocumented)
    CREATE_DEPLOYMENT = "create_deployment",
    // (undocumented)
    CREATE_GATEWAY = "create_gateway",
    // (undocumented)
    CREATE_LEAP_TOKEN = "create_leap_token",
    // (undocumented)
    CREATE_PROJECT_SECRET = "create_project_secret",
    // (undocumented)
    CREATE_PROJECT_TOKEN = "create_project_token",
    // (undocumented)
    CREATE_ROOM = "create_room",
    // (undocumented)
    CREATE_ROOM_PRODUCER = "create_room_producer",
    // (undocumented)
    DELETE_CHANNELS = "delete_channels",
    // (undocumented)
    DELETE_CONTAINER = "delete_container",
    // (undocumented)
    DELETE_DEPLOYMENT = "delete_deployment",
    // (undocumented)
    DELETE_DOMAIN = "delete_domain",
    // (undocumented)
    DELETE_GATEWAY = "delete_gateway",
    // (undocumented)
    DELETE_PROJECT = "delete_project",
    // (undocumented)
    DELETE_PROJECT_SECRET = "delete_project_secret",
    // (undocumented)
    DELETE_PROJECT_TOKEN = "delete_project_token",
    // (undocumented)
    DELETE_REGISTRY_IMAGES = "delete_registry_images",
    // (undocumented)
    DELETE_ROOM = "delete_room",
    // (undocumented)
    GET_INTERNAL_DOMAIN = "get_internal_domain",
    // (undocumented)
    GET_PROJECT_MEMBERS = "get_project_members",
    // (undocumented)
    GET_REGISTRY_IMAGES = "get_registry_images",
    // (undocumented)
    MANAGE_CHANNEL_SUBSCRIBERS = "manage_channel_subscribers",
    // (undocumented)
    MESSAGE_TOKEN = "message_token",
    // (undocumented)
    PUBLISH_CHANNEL_MESSAGES = "publish_channel_messages",
    // (undocumented)
    READ_BILLING = "read_billing",
    // (undocumented)
    READ_CHANNELS = "read_channels",
    // (undocumented)
    READ_CONTAINER_LOGS = "read_container_logs",
    // (undocumented)
    READ_DEPLOYMENTS = "read_deployments",
    // (undocumented)
    READ_GATEWAYS = "read_gateways",
    // (undocumented)
    READ_LEAP_TOKENS = "read_leap_tokens",
    // (undocumented)
    READ_PROJECT_SECRETS = "read_project_secrets",
    // (undocumented)
    READ_PROJECT_TOKENS = "read_project_tokens",
    // (undocumented)
    READ_ROOM = "read_room",
    // (undocumented)
    REMOVE_MEMBER = "remove_member",
    // (undocumented)
    REQUEST_QUOTA_INCREASE = "request_quota_increase",
    // (undocumented)
    ROLLOUT = "rollout",
    // (undocumented)
    TUNNEL_DEPLOYMENT = "tunnel_deployment",
    // (undocumented)
    UPDATE_CHANNEL_STATE = "update_channel_state",
    // (undocumented)
    UPDATE_CONTAINER_CONFIG = "update_container_config",
    // (undocumented)
    UPDATE_CONTAINER_STATE = "update_container_state",
    // (undocumented)
    UPDATE_LEAP_TOKEN = "update_leap_token"
}

// @public (undocumented)
export namespace Projects {
        {
        projects_DefaultQuotas as DefaultQuotas,
        projects_Member as Member,
        projects_MemberRole as MemberRole,
        projects_Project as Project,
        projects_ProjectTier as ProjectTier,
        projects_ProjectToken as ProjectToken,
        projects_ProjectType as ProjectType,
        projects_ProjectsEndpoints as ProjectsEndpoints,
        projects_QuotaOverrides as QuotaOverrides,
        projects_QuotaUsage as QuotaUsage,
        projects_Secret as Secret,
    };
}

// @public (undocumented)
export type ProjectsEndpoints = Endpoint<'DELETE', '/v1/projects/:project_id/tokens/:project_token_id', Empty> | Endpoint<'DELETE', '/v1/projects/@this/tokens/:project_token_id', Empty> | Endpoint<'GET', '/v1/projects/:project_id/members/@me', {
    project_member: Member;
}> | Endpoint<'GET', '/v1/projects/:project_id/tokens', {
    project_tokens: ProjectToken[];
}> | Endpoint<'GET', '/v1/projects/@this/tokens', {
    project_tokens: ProjectToken[];
}> | Endpoint<'GET', '/v1/projects/:project_id/members', {
    members: Member[];
}> | Endpoint<'GET', '/v1/projects/@this/members', {
    members: Member[];
}> | Endpoint<'POST', '/v1/projects/:project_id/tokens', {
    project_token: ProjectToken & {
        project: Project;
    };
}, {
    flags: number;
}> | Endpoint<'POST', '/v1/projects/@this/tokens', {
    project_token: ProjectToken & {
        project: Project;
    };
}, {
    flags: number;
}> | Endpoint<'PUT', '/v1/projects/:project_id/secrets/:name', {
    secret: Secret;
}, string> | Endpoint<'PUT', '/v1/projects/@this/secrets/:name', {
    secret: Secret;
}, string> | Endpoint<'GET', '/v1/projects/:project_id/secrets', {
    secrets: Secret[];
}> | Endpoint<'GET', '/v1/projects/@this/secrets', {
    secrets: Secret[];
}> | Endpoint<'DELETE', '/v1/projects/:project_id/secrets/:secret_id', Empty> | Endpoint<'DELETE', '/v1/projects/@this/secrets/:secret_id', Empty>;

// @public (undocumented)
export enum ProjectTier {
    // (undocumented)
    FREE = "free",
    // (undocumented)
    PAID = "paid"
}

// @public
export interface ProjectToken {
    created_at: Timestamp;
    flags: number;
    id: Id<'ptkid'>;
    token: Id<'ptk'>;
}

// @public
export enum ProjectType {
    PERSONAL = "personal",
    REGULAR = "regular"
}

// @public
export type Query<Path extends string> = ExtractRouteParams<Path> & Record<string, string | number | undefined>;

// @public (undocumented)
export interface QuotaOverrides {
}

// @public (undocumented)
export interface QuotaUsage {
    // (undocumented)
    ram: number;
    // (undocumented)
    vcpu: number;
    // (undocumented)
    volume: number;
}

// @public (undocumented)
export enum Regions {
    // (undocumented)
    US_EAST_1 = "us-east-1"
}

// @public (undocumented)
export namespace Registry {
        {
        registry_RegistryEndpoints as RegistryEndpoints,
    };
}

// @public (undocumented)
export type RegistryEndpoints = Endpoint<'DELETE', '/v1/registry/images/:image', Empty> | Endpoint<'GET', '/v1/registry/images', {
    images: string[];
}> | Endpoint<'GET', '/v1/registry/images/:image/manifests', {
    manifests: {
        digest: {
            digest: string;
            size: number;
            uploaded: string;
        };
        tag: string | null;
    }[];
}>;

// @public
export interface Resources {
    ram: ByteSizeString;
    vcpu: number;
    vgpu: Vgpu[];
}

// @public
export enum RestartPolicy {
    // (undocumented)
    ALWAYS = "always",
    // (undocumented)
    NEVER = "never",
    // (undocumented)
    ON_FAILURE = "on-failure"
}

// @public
export const roles: {
    viewer: bigint;
    editor: bigint;
    admin: bigint;
    owner: bigint;
};

// @public
export enum RolloutState {
    // (undocumented)
    FAILED = "failed",
    // (undocumented)
    FINISHED = "finished",
    // (undocumented)
    PENDING = "pending"
}

// @public (undocumented)
export interface Room {
    created_at: Timestamp;
    delivery_protocols: DeliveryProtocol[];
    id: Id<'pipe_room'>;
    ingest_endpoint: string;
    ingest_protocol: 'rtmp';
    ingest_region: Regions;
    join_token: string;
    name: string;
    state: 'live' | 'offline';
}

// @public
export enum RuntimeType {
    EPHEMERAL = "ephemeral",
    PERSISTENT = "persistent",
    STATEFUL = "stateful"
}

// @public (undocumented)
export interface Secret {
    created_at: Timestamp;
    digest: string;
    id: Id<'secret'>;
    in_use_by: Id<'deployment'>[];
    name: string;
}

// @public
export interface SelfUser extends User {
    admin: boolean;
    email_verified: boolean;
    mfa_enabled: boolean;
    totp_enabled: boolean;
    webauthn_enabled: boolean;
}

// @public
export type State = Record<string, unknown>;

// @public
export type SuccessfulAPIResponse<T> = {
    success: true;
    data: T;
};

// @public
export const SUPPORTS_INTL: boolean;

// @public
export type Tag<T, Name extends string> = T & {
    ___tag: Name;
};

// @public
export type Timestamp = Tag<string, 'timestamp'>;

// @public @deprecated (undocumented)
export const units: readonly ["GB", "MB", "KB", "B"];

// @public
export interface User {
    email: string;
    id: Id<'user'>;
    name: string;
    username: string;
}

// @public
export type UserEndpoints = Endpoint<'GET', '/v1/users/@me', {
    projects: Project[];
    user: SelfUser;
    project_member_role_map: Record<Id<'project'>, MemberRole>;
    leap_token: string | null;
}> | Endpoint<'POST', '/v1/users/@me/pats', {
    pat: PAT;
}, {
    name: string;
}> | Endpoint<'GET', '/v1/users/@me/pats', {
    pats: PAT[];
}> | Endpoint<'DELETE', '/v1/users/@me/pats/:pat_id', Empty>;

// @public (undocumented)
export namespace Users {
        {
        users_PAT as PAT,
        users_SelfUser as SelfUser,
        users_User as User,
        users_UserEndpoints as UserEndpoints,
    };
}

// @public
export function validateAPIAuthentication(auth: string): auth is APIAuthenticationPrefix;

// @public
export function validateId<T extends IdPrefixes = IdPrefixes>(maybeId: string | undefined | null, prefix?: T | T[]): maybeId is Id<T>;

// @public
export function validateIdPrefix<T extends IdPrefixes = IdPrefixes>(prefix: string, expect?: T): prefix is T;

// @public
export interface ValidationFailure {
    // (undocumented)
    help_link: string | null;
    // (undocumented)
    reason: string;
}

// @internal
export type _Values<T> = T[keyof T];

// @public
export interface Vgpu {
    count: number;
    type: VgpuType;
}

// @public
export enum VgpuType {
    // (undocumented)
    A400 = "a400"
}

// @public (undocumented)
export interface VolumeDefinition {
    fs: VolumeFormat;
    mount_path: string;
    size: ByteSizeString;
}

// @public (undocumented)
export enum VolumeFormat {
    // (undocumented)
    EXT4 = "ext4",
    // (undocumented)
    XFS = "xfs"
}

// Warnings were encountered during analysis:
//
// dist/index.d.ts:527:17 - (ae-incompatible-release-tags) The symbol "__call" is marked as @public, but its signature references "CreateDeploymentConfig" which is marked as @internal
// dist/index.d.ts:548:17 - (ae-incompatible-release-tags) The symbol "__call" is marked as @public, but its signature references "CreateDeploymentConfig" which is marked as @internal
// dist/index.d.ts:759:13 - (ae-forgotten-export) The symbol "SetStateAction" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
